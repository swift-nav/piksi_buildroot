#!/bin/sh

name="piksi_firmware"

settings_ini=/persistent/config.ini

uart_wait_count_limit=50 # wait 5s
uart_check_interval=0.1

svc_path()
{
  echo /var/run/ports_daemon/sv/${1}/supervise/stat
}

detect_sbp_mode()
{
  local the_port=$1; shift

  cat $settings_ini  | tr $'\n' ' ' | \
    grep -qE "\[${the_port}\][^\[]*mode=SBP"
}

port_disabled()
{
  local the_port=$1; shift

  # If it's SBP mode, then it's enabled
  if detect_sbp_mode $the_port; then
    return 1
  fi

  # If any other mode, it's effectively "disabled" for this check, if it's
  #   not there, then the default is SBP and it's *NOT* disabled
  cat $settings_ini  | tr $'\n' ' ' | \
    grep -qE "\[${the_port}\][^\[]*mode="
}

service_up()
{
  local svc=$1; shift
  local the_svc_path=$(svc_path $svc)

  if port_disabled $svc; then
    return 0
  fi

  grep -q run $the_svc_path
}

services_up()
{
  service_up uart0 && service_up uart1
}

wait_services()
{
  local uart_wait_count=0
  while ! services_up; do
    if [[ $uart_wait_count -ge $uart_wait_count_limit ]]; then
      echo "Timeout expired while waiting for UARTs" | sbp_log --err
      break;
    fi
    sleep $uart_check_interval;
    uart_wait_count=$(($uart_wait_count + 1))
  done
}

start()
{
  wait_services

  if [ -f "/lib/firmware/piksi_firmware.elf" ]; then
    modprobe zynq_remoteproc
  else
    echo "ERROR: firmware not found"
  fi
}

stop()
{
  rmmod zynq_remoteproc
}

source /etc/init.d/template_command.inc.sh

